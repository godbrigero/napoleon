plugins {
    id 'java'
    id 'edu.wpi.first.wpilib.repositories.WPILibRepositoriesPlugin' version '2025.0'
    id 'edu.wpi.first.GradleVsCode' version '2.1.0'
    id 'jacoco'
}

apply plugin: 'application'

application {
    mainClass = "org.pwrup.napoleon.Main" // Change this to your actual main class
}

ext.wpilibVersion = "2025.+"

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url "https://frcmaven.wpi.edu/artifactory/release/" }
}

dependencies {
    implementation "edu.wpi.first.cscore:cscore-java:$wpilibVersion"
    implementation "edu.wpi.first.cameraserver:cameraserver-java:$wpilibVersion"
    implementation "edu.wpi.first.ntcore:ntcore-java:$wpilibVersion"
    implementation "edu.wpi.first.wpilibj:wpilibj-java:$wpilibVersion"
    implementation "edu.wpi.first.wpiutil:wpiutil-java:$wpilibVersion"
    implementation "edu.wpi.first.wpimath:wpimath-java:$wpilibVersion"
    implementation "edu.wpi.first.wpiunits:wpiunits-java:$wpilibVersion"
    implementation "edu.wpi.first.hal:hal-java:$wpilibVersion"
    implementation "edu.wpi.first.wpilibNewCommands:wpilibNewCommands-java:$wpilibVersion"
    implementation "org.ejml:ejml-simple:0.43.1"
    implementation "com.fasterxml.jackson.core:jackson-annotations:2.15.2"
    implementation "com.fasterxml.jackson.core:jackson-core:2.15.2"
    implementation "com.fasterxml.jackson.core:jackson-databind:2.15.2"
    implementation 'edu.wpi.first.thirdparty.frc2025.opencv:opencv-java:4.10.0-2'
    implementation 'com.googlecode.json-simple:json-simple:1.1.1'
    implementation 'org.ejml:ejml-all:0.42'
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
}

// Add a specific task to run the pathfinding visualization
tasks.register('runPathfinder', JavaExec) {
    group = "application"
    description = "Runs the A* Pathfinder visualization"
    
    classpath = sourceSets.main.runtimeClasspath
    mainClass = "org.pwrup.napoleon.Napoleon"
    
    // Native libraries are expected to be in these directories
    systemProperty 'java.library.path', file("$buildDir/native-libs").absolutePath + 
                                       File.pathSeparator + 
                                       file("src/main/resources/native").absolutePath
    
    doFirst {
        println "Starting A* Pathfinder visualization..."
    }
}

runPathfinder.dependsOn build

tasks.register('buildRust') {
    doLast {
        def rustDir = "$projectDir/src/main/rust"
        def linuxReleaseDir = "target/arm-unknown-linux-gnueabi/release"
        def macReleaseDir = "target/release"
        def outputDir = file("$buildDir/native-libs")
        outputDir.mkdirs()

        println "Building Rust library for Linux..."
        exec {
            workingDir rustDir
            commandLine "cargo", "build", "--release", "--target", "arm-unknown-linux-gnueabi"
        }

        println "Building Rust library for macOS..."
        exec {
            workingDir rustDir
            commandLine "cargo", "build", "--release"
        }

        println "Looking for built Rust shared libraries..."
        def linuxFiles = fileTree(linuxReleaseDir).matching {
            include("libnapoleon_core.so")
        }
        def macFiles = fileTree(macReleaseDir).matching {
            include("libnapoleon_core.dylib")
        }

        if (linuxFiles.isEmpty() && macFiles.isEmpty()) {
            throw new GradleException("No Rust shared libraries found! Check if Cargo built them correctly.")
        }

        println "Found Linux libraries: " + linuxFiles.files
        println "Found macOS libraries: " + macFiles.files

        // Copy to build directory
        copy {
            from linuxFiles
            into outputDir
        }

        copy {
            from macFiles
            into outputDir
        }
    }
}

// Task to build dynamically from external repositories
tasks.register("buildDynamically") {
    group = "custom"
    description = "Build dependencies dynamically using the configuration file"

    doLast {
        def configFilePath = "./build-config.ini"
        exec {
            commandLine "python3", "scripts/clone_and_build_repos.py", "--config-file-path", configFilePath
        }
    }
}

// Collect dynamically built JAR files **before the JAR task runs**
def dynamicJars = fileTree(dir: "lib/build", include: "*.jar")

dependencies {
    implementation files(dynamicJars)  // Directly include dynamic JARs
}

// Ensure Rust and dynamic builds run before JAR
tasks.named('build').configure {
    dependsOn buildRust, buildDynamically
}


// Modify the jar task to include both Rust libraries and dynamically built JARs
jar {
    dependsOn buildRust, buildDynamically

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    // Include native libraries from both build directory and resources
    from("$buildDir/native-libs") {
        include("*.so", "*.dll", "*.dylib")
        into("native")
    }

    from("src/main/resources/native") {
        include("*.so", "*.dll", "*.dylib")
        into("native")
    }

    from("lib/build") {
        include("*.jar")
        into("libs")
    }

    manifest {
        attributes(
            "Main-Class": application.mainClass,
            "Pathfinder-Class": "org.pwrup.napoleon.Napoleon"
        )
    }
}

tasks.register('runJar', JavaExec) {
    dependsOn build // Ensure the JAR is built first
    group = "application"
    description = "Builds and runs the compiled JAR."

    doFirst {
        // Find the compiled JAR within the doFirst block after build has completed
        def jarFile = file("$buildDir/libs/${project.name}.jar")
        
        if (!jarFile.exists()) {
            throw new GradleException("JAR file not found! Check the build process.")
        }
        
        println "Running JAR: ${jarFile}"
        classpath = files(jarFile)
    }

    mainClass = "org.pwrup.napoleon.Main" // Change to your main class
    args = [] // Add any command-line arguments here if needed
}

// Add a task to run the pathfinder visualization from the compiled JAR
tasks.register('runPathfinderJar', JavaExec) {
    dependsOn build // Ensure the JAR is built first
    group = "application"
    description = "Runs the A* Pathfinder visualization from the compiled JAR"

    doFirst {
        // Find the compiled JAR within the doFirst block after build has completed
        def jarFile = file("$buildDir/libs/${project.name}.jar")
        
        if (!jarFile.exists()) {
            throw new GradleException("JAR file not found! Check the build process.")
        }
        
        println "Running Pathfinder visualization from JAR: ${jarFile}"
        classpath = files(jarFile)
    }

    mainClass = "org.pwrup.napoleon.Napoleon" // Use the Napoleon class directly
    
    // Add a system property to enable timing measurements 
    systemProperty 'pathfinder.timing.enabled', 'true'
}